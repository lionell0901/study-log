# ===================================================================
#            나만의 데이터 기차 만들기 (연결 리스트 기초)
# ===================================================================
# 이 코드는 컴퓨터가 데이터를 특별한 방식으로 저장하고 관리하는 방법 중
# 하나인 "연결 리스트"를 직접 만들어보는 예제입니다.
# 연결 리스트는 마치 기차처럼, 각 데이터 칸(객차)이 다음 칸을
# 가리키는 방식으로 연결되어 있는 구조입니다.

# -------------------------------------------------------------------
# 1. Node 클래스: 기차의 "객차" 역할을 하는 설계도
# -------------------------------------------------------------------
# 각 객차는 두 가지 중요한 정보를 가집니다:
#   - data: 객차 안에 실을 실제 데이터 (예: "사과", "바나나", 숫자 123)
#   - next: 다음 객차를 가리키는 연결고리 (다음 객차가 없으면 None)
class Node:
    def __init__(self, data=None):  # 객차를 만들 때 필요한 정보를 받는 곳
        # self는 "나 자신(이 객차)"을 의미합니다.
        self.data = data  # 이 객차에 실을 데이터를 저장합니다.
        self.next = None  # 새 객차는 아직 다음 객차와 연결되지 않았으므로 None으로 설정합니다.

# -------------------------------------------------------------------
# 2. MyList 클래스: "기차 전체"를 관리하는 설계도
# -------------------------------------------------------------------
# 이 클래스는 여러 개의 객차(Node)들을 모아서 하나의 기차처럼 관리합니다.
# 기차의 맨 앞(머리)과 맨 뒤(꼬리)를 항상 알고 있어서 관리가 편합니다.
class MyList:
    # head와 tail은 기차의 맨 앞과 맨 뒤를 표시하기 위한 특별한 "더미(dummy)" 객차입니다.
    # 더미 객차는 실제 데이터를 싣지는 않지만, 기차 관리를 쉽게 해주는 역할을 합니다.
    # head: 기차의 맨 앞(기관차 바로 뒤)을 가리키는 더미 객차
    # tail: 기차의 맨 뒤(마지막 객차 바로 뒤)를 가리키는 더미 객차
    def __init__(self):
        # 새 기차를 만들면 일단 머리와 꼬리 더미 객차만 있는 상태입니다.
        self.head = Node()  # 머리 더미 객차 생성
        self.tail = Node()  # 꼬리 더미 객차 생성
        
        # 처음에는 기차가 비어있으므로, 머리 더미 객차의 다음은 바로 꼬리 더미 객차입니다.
        self.head.next = self.tail
        # 꼬리 더미 객차의 다음은 자기 자신을 가리키도록 설정 (리스트 끝을 명확히 하는 방식 중 하나)
        # 또는 self.tail.next = None 으로 설정하여 끝을 표시할 수도 있습니다.
        self.tail.next = self.tail  

    # ---------------------------------------------------------------
    # 메소드(Method): MyList 객체가 할 수 있는 여러 가지 동작들
    # ---------------------------------------------------------------

    # 메소드 1: insertHead - 기차의 맨 앞에 새 객차 추가하기
    def insertHead(self, data):
        # 1. 새 데이터를 실을 새 객차(temp)를 만듭니다.
        temp = Node(data) # data라는 짐을 실은 새 객차
        
        # 2. 새 객차의 연결고리(next)를 현재 맨 앞에 있던 객차로 연결합니다.
        #    (원래 self.head.next가 가리키던 것이 첫 번째 실제 데이터 객차였음)
        temp.next = self.head.next
        
        # 3. 머리 더미 객차의 연결고리(next)가 이제 이 새 객차를 가리키도록 변경합니다.
        #    이제 새 객차가 기차의 맨 앞이 됩니다.
        self.head.next = temp

    # 메소드 2: print - 기차의 처음 3개 객차 내용 보여주기 (간단 버전)
    # 주의: 이 함수는 객차가 3개 미만이면 오류가 발생할 수 있습니다.
    def print(self):
        # 머리 더미 객차 바로 다음(첫 번째 실제 객차)의 데이터를 보여줍니다.
        print(self.head.next.data)
        # 첫 번째 실제 객차의 다음(두 번째 실제 객차)의 데이터를 보여줍니다.
        print(self.head.next.next.data)
        # 두 번째 실제 객차의 다음(세 번째 실제 객차)의 데이터를 보여줍니다.
        print(self.head.next.next.next.data)

    # 메소드 3: print2 - 기차의 모든 객차 내용 보여주기 (안전한 버전)
    def print2(self):
        # trace는 현재 우리가 살펴보고 있는 객차를 따라가는 역할을 합니다.
        # 머리 더미 객차의 다음(첫 번째 실제 객차)부터 시작합니다.
        trace = self.head.next
        
        # 현재 객차(trace)가 꼬리 더미 객차가 아닐 동안 계속 반복합니다.
        # (즉, 실제 데이터가 있는 모든 객차를 다 살펴볼 때까지)
        while trace != self.tail:
            print(trace.data)  # 현재 객차의 데이터를 보여줍니다.
            trace = trace.next # 다음 객차로 이동합니다.

    # 메소드 4: deleteHead - 기차의 맨 앞 객차 제거하기
    def deleteHead(self):
        # 만약 기차가 비어있으면 (머리 다음이 바로 꼬리면) 아무것도 안 합니다.
        if self.head.next == self.tail:
            return # 함수를 그냥 종료
        
        # 머리 더미 객차의 다음 연결고리를, 현재 첫 번째 실제 객차의 "다음" 객차로 바꿔버립니다.
        # 이렇게 하면 원래 첫 번째 실제 객차는 연결이 끊어져서 기차에서 떨어져 나갑니다.
        self.head.next = self.head.next.next
    
    # 메소드 5: deleteAll - 기차의 모든 객차 비우기
    def deleteAll(self): 
        # 아주 간단하게, 머리 더미 객차의 다음을 바로 꼬리 더미 객차로 연결해버립니다.
        # 이렇게 하면 중간에 있던 모든 실제 데이터 객차들과의 연결이 끊어집니다.
        # 파이썬은 이렇게 연결이 끊어진 객체들을 알아서 메모리에서 정리해줍니다.
        self.head.next = self.tail

    # 메소드 6: insertOrder - 데이터를 순서대로 (오름차순) 객차에 추가하기
    def insertOrder(self, data):
        # 1. 새 데이터를 실을 새 객차(temp)를 만듭니다.
        temp = Node(data)
        
        # 2. 새 객차가 들어갈 위치를 찾습니다.
        # t1은 현재 검사 중인 객차를, t2는 t1 바로 앞 객차를 따라갑니다.
        t1 = self.head.next # 첫 번째 실제 데이터 객차부터 시작
        t2 = self.head      # t2는 머리 더미 객차에서 시작
        
        # flag는 새 객차를 삽입할 위치를 찾았는지 알려주는 신호입니다.
        flag = False # 아직 못 찾았음
        
        # 신호를 아직 못 받았고(not flag), 현재 객차(t1)가 꼬리 더미 객차가 아닐 동안 반복합니다.
        while not flag and t1 != self.tail:
            # 만약 현재 객차(t1)의 데이터가 새 객차(temp)의 데이터보다 크면,
            # 바로 이 t1 앞에 새 객차를 넣어야 합니다 (오름차순이므로).
            if t1.data > temp.data:
                flag = True # 위치 찾았음! 신호 변경, 반복 중단.
            else:
                # 아직 더 큰 데이터를 못 만났으면, t1과 t2를 다음 칸으로 이동합니다.
                t1 = t1.next
                t2 = t2.next

        # 3. 찾은 위치에 새 객차(temp)를 삽입합니다.
        #    새 객차의 다음은 t1 (원래 t1이 있던 자리 또는 꼬리)이 되고,
        #    t2 (t1의 바로 앞 객차)의 다음은 새 객차(temp)가 됩니다.
        temp.next = t1
        t2.next = temp

# ===================================================================
#                       기차 운행 시뮬레이션!
# ===================================================================

# 1. MyList 클래스를 이용해 새 기차(m1)를 만듭니다.
m1 = MyList()

# 주석 처리된 이전 테스트 코드들:
# m1.insertHead("A") # 맨 앞에 "A" 객차 추가
# m1.insertHead("B") # 맨 앞에 "B" 객차 추가 (현재: B -> A)
# m1.insertHead("C") # 맨 앞에 "C" 객차 추가 (현재: C -> B -> A)
# m1.print2()        # 기차 내용 보여주기 (C, B, A 순으로 출력)
# print("삭제하기")
# m1.deleteHead()    # 맨 앞 "C" 객차 삭제 (현재: B -> A)
# m1.print2()        # 기차 내용 보여주기 (B, A 순으로 출력)

# 2. insertOrder 메소드를 사용해서 데이터를 순서대로 넣어봅니다.
#    (문자열은 알파벳 순서대로 비교됩니다)
m1.insertOrder("A") # 빈 기차에 "A" 추가 (기차: A)
m1.insertOrder("B") # "A" 다음에 "B" 추가 (기차: A -> B)
m1.insertOrder("C") # "B" 다음에 "C" 추가 (기차: A -> B -> C)
m1.insertOrder("D") # "C" 다음에 "D" 추가 (기차: A -> B -> C -> D)

# 3. 최종 기차 상태를 print2 메소드로 확인합니다.
m1.print2() # A, B, C, D 순으로 출력되어야 합니다.